# 进程切换
## 上下文
尽管每个进程都有自己的地址空间，但是所有的进程必须共享cpu寄存器,因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装入了挂起进程的值；
进程恢复执行前必须装入寄存器的一组数据称为**硬件上下文**；硬件上下文是进程可执行上下文的一个子集，因为可执行上下文包含进程执行时所需要的所有信息；在linux中，进程硬件上下文中的一部分存放在TSS段，而剩余部分存放在内核态的堆栈中；
当一个进程在执行时，CPU的所有寄存器的值、进程的状态以及堆栈中的内容被称为该进程的上下文；
上下文切换只能发生在内核态中，上下文切换通常是计算密集型的，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间；
## context_switch进程上下文切换
1. 调用switch_mm(),将虚拟内存从一个进程映射到新进程中；
2. 调用switch_to(),从上一个进程的处理器状态切换到新进程的处理器状态；这包括保存，恢复栈和寄存器信息；
   1. 首先切换了寄存器和栈，新进程在调用之后开始执行；
   2. switch之后的代码在当前进程(prev)下一次被选中之后才会执行；
   3. 为什么需要3个参数？ 举例：假定多个线程在系统上运行，在某个时间点，内核决定从进程A切换到进程B，此时prev=A，next=B;当后来的进程A再次被执行时，系统可能已经进行了多次的切换，假设此时为C切换到A,所以此时的prev=C，next=A，但是当A再次被执行时，其从切换的点的下一条指令开始执行，其上一次被切换时prev=A,next=B，此时内核将无法知道A之前的运行进程是C；通过对该信息的保留，我们可能需要做对对C的清理工作；*因为eax，ecx，edx是被调用者可以使用的寄存器，于是，prev传递给eax是实际刚被替换的进程的地址，eax可以简单理解为在当前过程中没有改变过，于是乎，我们可以在后面将prev即eax寄存器的值传递到next进程的堆栈中，其就知道打断了谁；